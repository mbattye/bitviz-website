<!DOCTYPE html>
<html>
<head>
    <title>Bitcoin Network Metrics</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <style>
        /* Theme variables */
        :root {
            --bg: #0f172a;
            --text: #e2e8f0;
            --muted: #94a3b8;
            --panel: #1e293b;
            --brand: #f7931a;
            --tooltip-bg: #334155;
            --tooltip-text: #e2e8f0;
            --map-fill: #1e293b;
            --map-stroke: #94a3b8;
        }

        :root[data-theme="light"] {
            --bg: #f8fafc;
            --text: #0f172a;
            --muted: #475569;
            --panel: #ffffff;
            --brand: #f7931a;
            --tooltip-bg: #ffffff;
            --tooltip-text: #0f172a;
            --map-fill: #e2e8f0;   /* slate-200 for land */
            --map-stroke: #94a3b8; /* slate-400 for borders */
        }

        body {
            background-color: var(--bg);
            color: var(--muted);
            font-family: system-ui, -apple-system, sans-serif;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .title {
            font-size: 1.5rem;
            color: var(--muted);
            margin-bottom: 2rem;
            transition: color 0.2s ease;
        }

        .title:hover {
            color: var(--brand);
            cursor: pointer;
        }

        .metrics-grid {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .metric-card {
            background: var(--panel);
            border-radius: 12px;
            padding: 1.5rem;
            transition: transform 0.2s ease;
            position: relative;
        }

        /* Loaders and errors */
        .metric-loader,
        .metric-error {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 1rem;
        }
        .metric-loader { pointer-events: none; }
        .metric-loader.active,
        .metric-error.show { display: flex; }
        .spinner { width: 26px; height: 26px; border: 3px solid var(--muted); border-top-color: var(--brand); border-radius: 50%; animation: spin .8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .metric-error { color: var(--muted); }

        .metric-card:hover {
            transform: translateY(-5px);
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .time-range-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .time-button {
            background: var(--panel);
            border: 1px solid var(--muted);
            color: var(--muted);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem;
            min-width: 44px;
        }

        .time-button:hover {
            border-color: var(--brand);
            color: var(--brand);
        }

        .time-button.active {
            background: var(--brand);
            border-color: var(--brand);
            color: #0f172a;
        }

        /* Focus styles */
        .time-button:focus-visible,
        .theme-toggle:focus-visible { outline: 2px solid var(--brand); outline-offset: 2px; border-radius: 6px; }

        .visualization {
            width: 100%;
        }

        .visualization.users-viz { height: 300px; }

        .visualization.miners-viz {
            height: 400px;
        }

        .visualization.nodes-viz {
            height: 900px;
        }

        .area-path {
            fill: #f7931a;
            fill-opacity: 0.2;
            stroke: #f7931a;
            stroke-width: 2;
        }

        .tooltip {
            position: absolute;
            padding: 8px;
            background: var(--tooltip-bg);
            border-radius: 4px;
            color: var(--tooltip-text);
            border: 1px solid rgba(0,0,0,0.08);
            box-shadow: 0 4px 10px rgba(0,0,0,0.08);
            font-size: 0.875rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .visualization svg {
            border: none;
        }

        .x-axis text, .y-axis text {
            font-size: 14px;
        }

        .treemap-cell {
            stroke: #0f172a;
            stroke-width: 1px;
            transition: opacity 0.2s;
        }

        .treemap-cell:hover {
            opacity: 0.8;
        }

        .treemap-label {
            font-size: 12px;
            fill: #fff;
            paint-order: stroke fill;
            stroke-width: 2px;
            stroke: rgba(0,0,0,0.35);
            pointer-events: none;
        }

        .metric-card.users { height: 360px; margin-bottom: 2rem; }

        .metric-card.miners {
            height: 500px;
            margin-bottom: 2rem;
        }

        .metric-card.nodes {
            height: 1000px;
        }

        .metric-card:last-child {
            margin-bottom: 0;
        }

        .home-button {
            position: fixed;
            top: 20px;
            left: 20px;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.3s;
            line-height: 0;
        }

        .home-button svg {
            width: 28px;
            height: 28px;
            fill: var(--muted);
            transition: fill 0.3s;
        }

        .home-button:hover svg { fill: var(--brand); }

        /* Theme toggle */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 36px;
            height: 36px;
            border-radius: 9999px;
            border: 1px solid var(--muted);
            background: var(--panel);
            color: var(--muted);
            display: grid;
            place-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .theme-toggle:hover { border-color: var(--brand); color: var(--brand); }
        .theme-toggle svg { width: 18px; height: 18px; }

        /* Basic tiles styling injection (keeps CSS block small) */
        (function injectTileStyles(){
            const css = `
            .metric-tile{background:var(--panel);border:1px solid rgba(148,163,184,0.25);border-radius:10px;padding:12px}
            .tile-label{font-size:.8rem;color:var(--muted);margin-bottom:4px}
            .tile-value{font-size:1.25rem;color:var(--text);font-weight:600}
            `;
            const s=document.createElement('style');s.textContent=css;document.head.appendChild(s);
        })();
    </style>
</head>
<body>
    <a href="/" class="home-button">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19 21H5a1 1 0 0 1-1-1v-9H1l10.327-9.388a1 1 0 0 1 1.346 0L23 11h-3v9a1 1 0 0 1-1 1zm-6-2h5v-9.15L12 4.2l-6 5.65V19h5v-3a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v3z"/>
        </svg>
    </a>
    <div class="container">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:1rem;">
            <h1 class="title" style="margin:0">Bitcoin Network Metrics</h1>
            <!-- Theme toggle (inline in header) -->
            <div style="display:flex; align-items:center; gap:8px;">
            <button id="fxToggle" class="theme-toggle" aria-label="Toggle currency" title="Toggle currency" style="position:static; width:42px;">
                <span id="fxLabel" style="font-size:.85rem;">GBP</span>
            </button>
            <button id="themeToggle" class="theme-toggle" aria-label="Toggle color theme" title="Toggle theme" style="position:static;">
                <svg id="iconSun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                </svg>
                <svg id="iconMoon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
            </button>
            </div>
        </div>

        <!-- Price & Market section -->
        <div class="metrics-grid" style="margin-bottom: 2rem;">
            <div class="metric-card" id="market-section">
                <div class="metric-header">
                    <h2>Price & Market</h2>
                </div>
                <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px;">
                    <div class="metric-tile"><div class="tile-label">Spot (GBP)</div><div class="tile-value" id="ms-spot">—</div></div>
                    <div class="metric-tile"><div class="tile-label">ATH (GBP)</div><div class="tile-value" id="ms-ath">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Drawdown from ATH</div><div class="tile-value" id="ms-dd">—</div></div>
                    <div class="metric-tile"><div class="tile-label">30d Vol (ann.)</div><div class="tile-value" id="ms-vol30">—</div></div>
                    <div class="metric-tile"><div class="tile-label">90d Vol (ann.)</div><div class="tile-value" id="ms-vol90">—</div></div>
                    <div class="metric-tile"><div class="tile-label">% Days Above Price</div><div class="tile-value" id="ms-pctabove">—</div></div>
                    <div class="metric-tile"><div class="tile-label">200D SMA</div><div class="tile-value" id="ms-sma200">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Mayer Multiple</div><div class="tile-value" id="ms-mayer">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Distance to 200D</div><div class="tile-value" id="ms-smaDist">—</div></div>
                </div>
            </div>
        </div>

        <!-- On-chain Supply section -->
        <div class="metrics-grid" style="margin-bottom: 2rem;">
            <div class="metric-card" id="supply-section">
                <div class="metric-header">
                    <h2>On-chain Supply</h2>
                </div>
                <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; align-items: stretch;">
                    <div class="metric-tile"><div class="tile-label">Height</div><div class="tile-value" id="oc-height">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Epoch</div><div class="tile-value" id="oc-epoch">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Blocks to Halving</div><div class="tile-value" id="oc-bth">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Halving ETA</div><div class="tile-value" id="oc-eta">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Current Subsidy (BTC)</div><div class="tile-value" id="oc-subsidy">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Annual Issuance (BTC)</div><div class="tile-value" id="oc-issue">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Circulating Supply</div><div class="tile-value" id="oc-circ">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Max Supply</div><div class="tile-value" id="oc-max">—</div></div>
                    <div class="metric-tile"><div class="tile-label">% of Max Mined</div><div class="tile-value" id="oc-circpct">—</div></div>
                </div>
            </div>
        </div>

        <div class="metrics-grid">
            <!-- Miner & Economics section -->
            <div class="metric-card" id="miners-econ">
                <div class="metric-header">
                    <h2>Miner & Economics</h2>
                </div>
                <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                    <div class="metric-tile"><div class="tile-label">Hashrate (7d avg)</div><div class="tile-value" id="me-hr">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Miner Revenue</div><div class="tile-value" id="me-rev">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Fees</div><div class="tile-value" id="me-fees">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Fees % of Revenue</div><div class="tile-value" id="me-feesPct">—</div></div>
                </div>
                <div style="margin-top:12px; color:var(--muted); font-size:.9rem;">Mining Distribution</div>
                <div id="miners-loader" class="metric-loader"><div class="spinner"></div></div>
                <div id="miners-error" class="metric-error">Unable to load mining data. Please try again.</div>
                <div id="miners-viz" class="visualization miners-viz" style="margin-top:8px;"></div>
            </div>

            <div class="metric-card users">
                <div class="metric-header">
                    <h2>Active Users</h2>
                    <div class="time-range-buttons">
                        <button class="time-button" data-range="7days">7D</button>
                        <button class="time-button active" data-range="30days">30D</button>
                        <button class="time-button" data-range="1year">1Y</button>
                        <button class="time-button" data-range="all">All</button>
                    </div>
                </div>
                <div id="users-loader" class="metric-loader"><div class="spinner"></div></div>
                <div id="users-error" class="metric-error">Unable to load users data. Please try again.</div>
                <div id="users-viz" class="visualization users-viz"></div>
                <div style="margin-top:12px; color:var(--muted); font-size:.9rem;">Adoption & Usage</div>
                <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-top:8px;">
                    <div class="metric-tile"><div class="tile-label">LN Capacity (BTC)</div><div class="tile-value" id="au-ln">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Active Addresses (latest)</div><div class="tile-value" id="au-aa">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Transactions per Day</div><div class="tile-value" id="au-tx">—</div></div>
                    <div class="metric-tile"><div class="tile-label">Avg Fee / Tx</div><div class="tile-value" id="au-fee">—</div></div>
                </div>
            </div>
            <div class="metric-card nodes">
                <div class="metric-header">
                    <h2>Network Nodes</h2>
                </div>
                <div id="nodes-loader" class="metric-loader"><div class="spinner"></div></div>
                <div id="nodes-error" class="metric-error">Unable to load nodes map. Please try again.</div>
                <div id="nodes-viz" class="visualization nodes-viz"></div>
            </div>
        </div>
    </div>

    <script>
        // Minimal theme init and toggle
        (function initTheme() {
            const root = document.documentElement;
            const saved = localStorage.getItem('theme');
            const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
            const initial = saved || (prefersLight ? 'light' : 'dark');
            root.setAttribute('data-theme', initial);
            const iconSun = document.getElementById('iconSun');
            const iconMoon = document.getElementById('iconMoon');
            if (iconSun && iconMoon) {
                const isLight = initial === 'light';
                iconSun.style.display = isLight ? 'none' : '';
                iconMoon.style.display = isLight ? '' : 'none';
            }
        })();

        (function wireThemeToggle(){
            const btn = document.getElementById('themeToggle');
            if (!btn) return;
            btn.addEventListener('click', () => {
                const root = document.documentElement;
                const current = root.getAttribute('data-theme') || 'dark';
                const next = current === 'light' ? 'dark' : 'light';
                root.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
                const iconSun = document.getElementById('iconSun');
                const iconMoon = document.getElementById('iconMoon');
                if (iconSun && iconMoon) {
                    const isLight = next === 'light';
                    iconSun.style.display = isLight ? 'none' : '';
                    iconMoon.style.display = isLight ? '' : 'none';
                }
            });
        })();

        let currentTimeRange = '30days';

        // Cache for API responses to handle rate limiting
        const cache = {
            users: { data: null, timestamp: 0 },
            miners: { data: null, timestamp: 0 },
            nodes: { data: null, timestamp: 0 }
        };

        // Cache duration (5 minutes)
        const CACHE_DURATION = 5 * 60 * 1000;

        async function fetchWithCache(url, cacheKey) {
            const now = Date.now();
            if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_DURATION) {
                return cache[cacheKey].data;
            }

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                cache[cacheKey] = { data, timestamp: now };
                return data;
            } catch (error) {
                console.error(`Error fetching ${cacheKey} data:`, error);
                return cache[cacheKey]?.data; // Return cached data if available
            }
        }

        // Helper: retry with backoff
        async function fetchJsonWithRetry(url, retries = 2, backoffMs = 800) {
            let lastErr;
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    const resp = await fetch(url);
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    return await resp.json();
                } catch (err) {
                    lastErr = err;
                    if (attempt < retries) {
                        await new Promise(r => setTimeout(r, backoffMs * Math.pow(2, attempt)));
                        continue;
                    }
                }
            }
            throw lastErr;
        }

        // Helper: cache + retry wrapper
        async function fetchWithCacheRetry(url, cacheKey, retries = 2, backoffMs = 800) {
            const now = Date.now();
            if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_DURATION) {
                return cache[cacheKey].data;
            }
            const data = await fetchJsonWithRetry(url, retries, backoffMs);
            cache[cacheKey] = { data, timestamp: now };
            return data;
        }

        async function fetchNetworkData(timeRange = currentTimeRange) {
            try {
                // show loaders and clear errors
                const uL = document.getElementById('users-loader');
                const mL = document.getElementById('miners-loader');
                const nL = document.getElementById('nodes-loader');
                const uE = document.getElementById('users-error');
                const mE = document.getElementById('miners-error');
                const nE = document.getElementById('nodes-error');
                [uE,mE,nE].forEach(el => el && el.classList.remove('show'));
                [uL,mL,nL].forEach(el => el && el.classList.add('active'));

                const [usersData, minersData, nodesData] = await Promise.all([
                    fetchWithCacheRetry(
                        `https://api.blockchain.info/charts/n-unique-addresses?timespan=${timeRange}&format=json&cors=true`,
                        `users-${timeRange}`
                    ).catch(e => { console.error('users fetch failed', e); return null; }),
                    fetchWithCacheRetry(
                        'https://api.blockchain.info/pools?timespan=5days',
                        'miners-5days'
                    ).catch(e => { console.error('miners fetch failed', e); return null; }),
                    fetchWithCacheRetry(
                        '/api/nodes-latest',
                        'nodes-latest'
                    ).catch(e => { console.error('nodes fetch failed', e); return null; })
                ]);

                if (usersData) updateUsersVisualization(usersData); else uE && uE.classList.add('show');
                if (minersData) updateMinersVisualization(minersData); else mE && mE.classList.add('show');
                // Always render map; if nodes unavailable, show map without nodes (no error overlay)
                updateNodesVisualization(nodesData || { nodes: {} });
            } catch (error) {
                console.error('Error in fetchNetworkData:', error);
            } finally {
                const uL = document.getElementById('users-loader');
                const mL = document.getElementById('miners-loader');
                const nL = document.getElementById('nodes-loader');
                [uL,mL,nL].forEach(el => el && el.classList.remove('active'));
            }
        }

        function updateUsersVisualization(data) {
            console.log('Updating visualization with data:', data);

            // Clear previous visualization
            const container = document.getElementById('users-viz');
            container.innerHTML = '';

            const margin = { top: 20, right: 20, bottom: 30, left: 70 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            console.log('Container dimensions:', { width, height });

            const svg = d3.select('#users-viz')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Ensure we have data to visualize
            if (!data.values || !data.values.length) {
                console.error('No data available');
                return;
            }

            const x = d3.scaleTime()
                .domain(d3.extent(data.values, d => new Date(d.x * 1000)))
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data.values, d => d.y)])
                .range([height, 0]);

            // Add area path
            const area = d3.area()
                .x(d => x(new Date(d.x * 1000)))
                .y0(height)
                .y1(d => y(d.y))
                .curve(d3.curveMonotoneX);

            svg.append('path')
                .datum(data.values)
                .attr('class', 'area-path')
                .attr('d', area);

            // Adjust tick format based on time range
            const xAxisTickFormat = currentTimeRange === '24h' ? d3.timeFormat("%H:%M") :
                                  currentTimeRange === '30days' ? d3.timeFormat("%b %d") :
                                  currentTimeRange === '1year' ? d3.timeFormat("%b %Y") :
                                  d3.timeFormat("%Y");

            // Update X axis with new format
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .attr('class', 'x-axis')
                .call(d3.axisBottom(x)
                    .ticks(5)
                    .tickFormat(xAxisTickFormat))
                .attr('color', '#94a3b8')
                .style('font-size', '12px');

            // Adjust Y axis tick intervals based on time range
            const yAxisTicks = currentTimeRange === '7days' || currentTimeRange === '30days'
                ? d3.range(0, d3.max(data.values, d => d.y), 100000)
                : d3.range(0, d3.max(data.values, d => d.y), 200000);

            // Update Y axis with new tick intervals
            svg.append('g')
                .attr('class', 'y-axis')
                .call(d3.axisLeft(y)
                    .tickValues(yAxisTicks)
                    .tickFormat(d => d3.format(",")(d)))
                .attr('color', '#94a3b8')
                .style('font-size', '12px');

            // Add tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip');

            const bisect = d3.bisector(d => new Date(d.x * 1000)).left;

            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mousemove', function(event) {
                    const x0 = x.invert(d3.pointer(event, this)[0]);
                    const i = bisect(data.values, x0, 1);
                    const d0 = data.values[i - 1];
                    const d1 = data.values[i];
                    const d = x0 - d0.x > d1.x - x0 ? d1 : d0;

                    tooltip
                        .style('opacity', 1)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px')
                        .html(`Date: ${new Date(d.x * 1000).toLocaleDateString()}<br>Users: ${d.y.toLocaleString()}`);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
        }

        function updateMinersVisualization(data) {
            const container = document.getElementById('miners-viz');
            container.innerHTML = '';

            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select('#miners-viz')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Sort and normalize the data
            const sortedEntries = Object.entries(data)
                .sort((a, b) => b[1] - a[1]); // Sort by value descending

            const total = sortedEntries.reduce((sum, [_, value]) => sum + value, 0);
            const normalizedData = sortedEntries.map(([key, value]) => ({
                name: key,
                value: value / total
            }));

            // Create hierarchical data
            const root = d3.hierarchy({
                children: normalizedData
            })
            .sum(d => d.value);

            // Create treemap layout
            d3.treemap()
                .size([width, height])
                .padding(1)
                (root);

            // Create color scale with explicit domain
            const colorScale = d3.scaleOrdinal()
                .domain(normalizedData.map(d => d.name))
                .range(d3.schemeOranges[9]);

            // Create cells
            const cell = svg.selectAll('g')
                .data(root.leaves())
                .join('g')
                .attr('transform', d => `translate(${d.x0},${d.y0})`);

            cell.append('rect')
                .attr('class', 'treemap-cell')
                .attr('width', d => d.x1 - d.x0)
                .attr('height', d => d.y1 - d.y0)
                .attr('fill', d => colorScale(d.data.name));

            // Add labels
            cell.append('text')
                .attr('class', 'treemap-label')
                .attr('x', 3)
                .attr('y', 13)
                .attr('fill', d => {
                    const cellWidth = d.x1 - d.x0;
                    const cellHeight = d.y1 - d.y0;
                    if (cellWidth < 60 || cellHeight < 30) return 'transparent';
                    const fill = d3.color(colorScale(d.data.name));
                    if (!fill) return '#0f172a';
                    const brightness = (fill.r * 299 + fill.g * 587 + fill.b * 114) / 1000;
                    return brightness > 150 ? '#0f172a' : '#ffffff';
                })
                .attr('stroke', d => {
                    const fill = d3.color(colorScale(d.data.name));
                    if (!fill) return 'rgba(0,0,0,0.35)';
                    const brightness = (fill.r * 299 + fill.g * 587 + fill.b * 114) / 1000;
                    return brightness > 150 ? 'rgba(255,255,255,0.45)' : 'rgba(0,0,0,0.35)';
                })
                .text(d => {
                    const cellWidth = d.x1 - d.x0;
                    const cellHeight = d.y1 - d.y0;
                    const text = cellWidth < 60 || cellHeight < 30 ? '' : d.data.name;
                    return text;
                });

            // Add tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip');

            cell.on('mousemove', function(event, d) {
                tooltip
                    .style('opacity', 1)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px')
                    .html(`
                        ${d.data.name}<br>
                        Hashrate: ${Math.round(d.data.value * 100)}%
                    `);
            })
            .on('mouseout', () => tooltip.style('opacity', 0));
        }

        function updateNodesVisualization(data) {
            const container = document.getElementById('nodes-viz');
            container.innerHTML = '';

            // Fine-tune margins
            const margin = { top: 0, right: 20, bottom: 40, left: 20 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            console.log('Container dimensions:', { width, height }); // Debug log

            const svg = d3.select('#nodes-viz')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Adjust projection to make map bigger while maintaining aspect ratio
            const projection = d3.geoMercator()
                .scale((width / 2.2) / Math.PI)  // Increased scale for bigger map
                .translate([width / 2, height / 1.65]);

            const path = d3.geoPath().projection(projection);

            // Load world map data
            d3.json("https://unpkg.com/world-atlas@2/countries-110m.json").then(worldData => {
                // Draw world map
                svg.append("g")
                    .selectAll("path")
                    .data(topojson.feature(worldData, worldData.objects.countries).features)
                    .join("path")
                    .attr("fill", cssVar('--map-fill', '#1e293b'))
                    .attr("stroke", cssVar('--map-stroke', '#94a3b8'))
                    .attr("stroke-width", 0.5)
                    .attr("d", path);

                // Process nodes data - using address field to get coordinates
                const nodesArray = [];
                const entries = data && data.nodes ? Object.entries(data.nodes) : [];
                for (const [nodeId, nodeInfo] of entries) {
                    // The address field contains the IP:PORT
                    const address = nodeInfo[1];  // Get the address string
                    if (nodeInfo[8] && nodeInfo[9]) {  // Check if lat/lon exists
                        nodesArray.push({
                            id: nodeId,
                            address: address,
                            latitude: nodeInfo[8],  // Latitude
                            longitude: nodeInfo[9], // Longitude
                            version: nodeInfo[2]    // Node version
                        });
                    }
                }

                console.log('Processed nodes:', nodesArray.slice(0, 5));

                // Add nodes to the map
                svg.selectAll("circle.node")
                    .data(nodesArray)
                    .join("circle")
                    .attr("class", "node")
                    .attr("cx", d => {
                        const projectedCoords = projection([d.longitude, d.latitude]);
                        return projectedCoords ? projectedCoords[0] : null;
                    })
                    .attr("cy", d => {
                        const projectedCoords = projection([d.longitude, d.latitude]);
                        return projectedCoords ? projectedCoords[1] : null;
                    })
                    .attr("r", 3.2)
                    .attr("fill", cssVar('--brand', '#f7931a'))
                    .attr("opacity", 0.6)
                    .attr("stroke", cssVar('--panel', '#0f172a'))
                    .attr("stroke-width", 0.5);

                // Add hover effects
                const tooltip = d3.select('body').append('div')
                    .attr('class', 'tooltip');

                svg.selectAll("circle.node")
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .attr("r", 5)
                            .attr("opacity", 1);

                        tooltip
                            .style("opacity", 1)
                            .html(`
                                Node Version: ${d.version}<br>
                                Address: ${d.address}<br>
                                Location: ${d.latitude.toFixed(2)}, ${d.longitude.toFixed(2)}
                            `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .attr("r", 3)
                            .attr("opacity", 0.6);

                        tooltip.style("opacity", 0);
                    });
            });
        }

        // Add event listeners to time range buttons
        let metricsClickLock = false;
        document.querySelectorAll('.time-button').forEach(button => {
            button.addEventListener('click', async (e) => {
                if (metricsClickLock) return;
                metricsClickLock = true;
                const buttons = Array.from(document.querySelectorAll('.time-button'));
                buttons.forEach(b => b.disabled = true);
                try {
                // Update active button
                    buttons.forEach(btn => btn.classList.remove('active'));
                    e.currentTarget.classList.add('active');

                // Update data
                    currentTimeRange = e.currentTarget.dataset.range;
                await fetchNetworkData(currentTimeRange);
                } finally {
                    const buttons = Array.from(document.querySelectorAll('.time-button'));
                    buttons.forEach(b => b.disabled = false);
                    setTimeout(() => { metricsClickLock = false; }, 200);
                }
            });
        });

        // Basic tiles styling injection (keeps CSS block small)
        (function injectTileStyles(){
            const css = `
            .metric-tile{background:var(--panel);border:1px solid rgba(148,163,184,0.25);border-radius:10px;padding:12px}
            .tile-label{font-size:.8rem;color:var(--muted);margin-bottom:4px}
            .tile-value{font-size:1.25rem;color:var(--text);font-weight:600}
            `;
            const s=document.createElement('style');s.textContent=css;document.head.appendChild(s);
        })();

        async function loadMarketStructure(){
            try{
                const res = await fetch('/api/market-structure');
                if(!res.ok) throw new Error(`HTTP ${res.status}`);
                const ms = await res.json();
                const f = (n,opts)=> n==null? '—' : n.toLocaleString('en-GB',opts);
                document.getElementById('ms-spot').textContent = '£'+f(ms.spot_gbp,{maximumFractionDigits:0});
                document.getElementById('ms-ath').textContent = '£'+f(ms.ath_gbp,{maximumFractionDigits:0});
                document.getElementById('ms-dd').textContent = f(ms.drawdown_from_ath_pct,{maximumFractionDigits:2})+'%';
                document.getElementById('ms-vol30').textContent = f(ms.volatility_30d_annualized_pct,{maximumFractionDigits:1})+'%';
                document.getElementById('ms-vol90').textContent = f(ms.volatility_90d_annualized_pct,{maximumFractionDigits:1})+'%';
                document.getElementById('ms-pctabove').textContent = f(ms.pct_days_above_current_pct,{maximumFractionDigits:1})+'%';
                document.getElementById('ms-sma200').textContent = '£'+f(ms.sma200_gbp,{maximumFractionDigits:0});
                document.getElementById('ms-mayer').textContent = f(ms.mayer_multiple,{maximumFractionDigits:3});
                document.getElementById('ms-smaDist').textContent = f(ms.sma200_distance_pct,{maximumFractionDigits:2})+'%';
            }catch(e){
                console.error('market-structure fetch failed', e);
            }
        }

        async function loadOnchainSupply(){
            try{
                const r = await fetch('/api/onchain-supply');
                if(!r.ok) throw new Error(`HTTP ${r.status}`);
                const s = await r.json();
                const f = (n,opts)=> n==null? '—' : n.toLocaleString('en-GB',opts);
                document.getElementById('oc-height').textContent = f(s.height);
                document.getElementById('oc-epoch').textContent = f(s.epoch);
                document.getElementById('oc-bth').textContent = f(s.blocks_to_halving);
                document.getElementById('oc-eta').textContent = s.eta_utc ? new Date(s.eta_utc).toLocaleDateString('en-GB') : '—';
                document.getElementById('oc-subsidy').textContent = f(s.current_subsidy_btc,{maximumFractionDigits:8});
                document.getElementById('oc-issue').textContent = f(s.annual_issuance_btc,{maximumFractionDigits:0});
                document.getElementById('oc-circ').textContent = f(s.circulating_supply,{maximumFractionDigits:0});
                document.getElementById('oc-max').textContent = f(s.max_supply,{maximumFractionDigits:0});
                document.getElementById('oc-circpct').textContent = f(s.circulating_pct_of_max,{maximumFractionDigits:2})+'%';
            }catch(e){
                console.error('onchain-supply fetch failed', e);
            }
        }

        let fx = { mode: 'GBP', gbp_per_usd: 0.78 };
        async function fetchFx(){
            try{ const r=await fetch('/api/fx-rate'); if(r.ok){ const j=await r.json(); fx.gbp_per_usd=j.gbp_per_usd||fx.gbp_per_usd; } }catch(_){/*noop*/}
        }

        async function loadMinerEconomics(){
            try{
                const r = await fetch('/api/miner-economics');
                if(!r.ok) throw new Error(`HTTP ${r.status}`);
                const m = await r.json();
                const f = (n,opts)=> n==null? '—' : n.toLocaleString('en-GB',opts);
                document.getElementById('me-hr').textContent = f(m.hashrate_7d_avg,{maximumFractionDigits:2});
                const revUSD = m.miners_revenue_usd;
                const feesUSD = m.fees_usd;
                if(fx.mode==='GBP'){
                    const revGBP = revUSD==null? null : revUSD*fx.gbp_per_usd;
                    const feesGBP = feesUSD==null? null : feesUSD*fx.gbp_per_usd;
                    document.getElementById('me-rev').textContent = '£'+f(revGBP,{maximumFractionDigits:0});
                    document.getElementById('me-fees').textContent = '£'+f(feesGBP,{maximumFractionDigits:0});
                } else {
                    document.getElementById('me-rev').textContent = '$'+f(revUSD,{maximumFractionDigits:0});
                    document.getElementById('me-fees').textContent = '$'+f(feesUSD,{maximumFractionDigits:0});
                }
                document.getElementById('me-feesPct').textContent = f(m.fees_pct_of_revenue,{maximumFractionDigits:2})+'%';
            }catch(e){
                console.error('miner-economics fetch failed', e);
            }
        }

        async function loadAdoptionUsage(){
            try{
                const r = await fetch('/api/adoption-usage');
                if(!r.ok) throw new Error(`HTTP ${r.status}`);
                const a = await r.json();
                const f = (n,opts)=> n==null? '—' : n.toLocaleString('en-GB',opts);
                document.getElementById('au-ln').textContent = f(a.ln_capacity_btc,{maximumFractionDigits:2});
                document.getElementById('au-aa').textContent = f(a.active_addresses,{maximumFractionDigits:0});
                document.getElementById('au-tx').textContent = f(a.transactions_per_day,{maximumFractionDigits:0});
                // fee in USD -> convert to GBP if needed
                const feeUSD = a.avg_fee_per_tx_usd;
                if(fx.mode==='GBP'){
                    const feeGBP = feeUSD==null? null : feeUSD*fx.gbp_per_usd;
                    document.getElementById('au-fee').textContent = feeGBP==null? '—' : '£'+feeGBP.toFixed(2);
                } else {
                    document.getElementById('au-fee').textContent = feeUSD==null? '—' : '$'+feeUSD.toFixed(2);
                }
            }catch(e){ console.error('adoption-usage fetch failed', e); }
        }

        // Initial load
        loadMarketStructure();
        loadOnchainSupply();
        fetchFx().then(()=>{ loadMinerEconomics(); loadAdoptionUsage(); });
        fetchNetworkData();
        // Update every 5 minutes
        setInterval(fetchNetworkData, CACHE_DURATION);

        // Currency toggle wiring
        document.getElementById('fxToggle').addEventListener('click', async ()=>{
            fx.mode = fx.mode==='GBP' ? 'USD' : 'GBP';
            document.getElementById('fxLabel').textContent = fx.mode;
            await fetchFx();
            // Re-render currency-sensitive tiles
            await loadMinerEconomics();
            await loadAdoptionUsage();
            // Price & Market: just re-fetch market structure (it returns GBP values); for now display GBP only
            // Optionally, later extend backend to return USD too.
        });
    </script>
</body>
</html> 